

When performing software tasks in large and complex software systems, software developers typically consult a number of different kinds of artifacts that assist them in their work~\cite{Starke2009, Meyer2017}. For example, 
when developing an Android application, a developer might consult official Android API documents and guidelines~\cite{robillard2011field, umarji2008archetypal} or she might consult question-and-answer forums for functionality, security and performance-related topics~\cite{parnin2012, silva2019}.




Much critical information in this and other non-source code types of artifacts 
contain data in the form of unstructured text~\cite{Bavota2016} and 
a developer must read the text to find the information that is \textit{relevant} to the task being performed.
However, the sheer amount of information \textit{within} these natural language artifacts may prevent a developer from comprehensively assessing what is useful to their task~\cite{Murphy2005}.  Just within one kind of document, API
documentation, studies have shown that it can take 15 minutes or more
of a developer's highly constrained time to identify 
information needed to perform a particular software task~\cite{endrikat2014, Meyer2017}.


Finding information that assists a developer complete a task can be a time-consuming
and cognitively frustrating process~\cite{Begel2008,
robillard2011field}.
If no tool support is provided, much of this information foraging process~\cite{Pirolli1999, Just1980} falls on the developer's shoulders~\cite{gonccalves2011, Ko2006a, Bystrom1995} and a developer that fails to locate all, or most, of the information needed
 will have an incomplete or incorrect basis from which to perform a software task~\cite{Murphy2005}.





Researchers have long recognized the need to assist a developer's discovery of information,
utilizing a number of
\textit{artifact-centric} techniques
to extract
information that can be embedded in
tools for software developers. 
A number of the techniques commonly employed by researchers utilize pattern matching (or regular expressions)~\cite{Maalej2013, Bavota2014, Chaparro2017}   
to check for specific sequences of tokens often present in text relevant to certain tasks. For example, \textit{Krec}~\cite{Robillard2015} utilizes pattern matching to identify text that a developer cannot afford to ignore when reading an API document.
Other techniques that researchers have explored rely on extractive text summarization~\cite{Rastkar2010, Lotufo2012, Murray2008}. 
A summary can be interpreted as the most relevant information in a software artifact 
and tools, such as \textit{DeepSum}~\cite{Li2018}, summarize the content of an artifact 
to assist developers in determining what is most relevant for their task.






Although effective, this and other techniques~\cite{Lotufo2012, Ponzanelli2014, nadi2020} typically
target specific kinds of task as well as particular types of artifact, limiting their use across the
many different kinds of artifacts developers encounter
daily in their work~\cite{Meyer2017, meyer2019}.
If one technique identify relevant text across the various kinds
of artifacts a developer encounters according to the task they currently perform,
it would be possible for a
developer to quickly access information needed 
to complete their task.





