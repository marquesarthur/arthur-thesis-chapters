\section{Finding Pertinent Artifacts}
\label{cp2:foraging-tools}



Software development often requires knowledge beyond what developers already posses~\cite{Li2013} and thus, 
software developers use different information sources to fill such gaps. 
More than often, a developer will ask if any of their 
peers have the information that they need~\cite{singer2011}. 
However, the fragmented and distributed nature of software development work 
might prevent a developer from approaching their peers~\cite{ko2007}.
Due to this and other reasons, a developer might seek
online web resources for information 
that may assist them in completing the task-at-hand~\cite{Xia2017, rao2020}.




To help a developer find artifacts of interest for a task,
several approaches
using 
standard \acf{IR} techniques or more advanced \acf{ML} techniques have been developed.
Other approaches leverage crowd knowledge, i.e.,
the use of data produced by other developers for finding artifacts pertinent to a developer's task.



This thesis assumes the usage of one or more of such techniques to locate pertinent
artifacts
from which task-relevant text will be extracted. As such, the following 
subsections provide a breadth of approaches in the literature. 




\subsection{Information Retrieval Approaches} 



Standard information retrieval approaches locate pertinent artifacts
using metrics to compute the relevance of an artifact to a query posed manually by a developer.
\acs{IR} uses the terms shared between a search query and an artifact
to compute the relevance of an artifact (or document).
Search algorithms weight and compute relevance based on 
criteria such as how many documents contain a given term or  
how unique a term is~\cite{Manning2009IR}.



A number of the techniques commonly employed by software engineering researchers are based on the
frequency of co-occurrence of words (or phrases) in documents.
An early example is Maarek and Smadja's use of lexical relations to index
software libraries~\cite{maarek1989}.
Since this early use, software engineering
researchers have continued to leverage advances in
these approaches, such as when
Antoniol et al. applied \acf{VSM}~\cite{Salton1975vsm} 
to construct vector representations 
for recovering traceability links 
between code and documentation~\cite{antoniol1999, antoniol2000}.
Other examples include Maletic and Marcus usage of \acf{LSI}~\cite{deerwester1990LSI}
to help cluster software components to aid
program comprehension of a software system~\cite{Marcus2003}.



While IR systems are widely used, researchers 
observed that developers often find it difficult to identify good search terms~\cite{Kevic2014, Huang2018}
and thus, the identification of good search terms is as 
important as the search algorithm itself~\cite{Kevic2014, mills2017}.
Hence, software engineering researchers have proposed approaches~\cite{Kevic2014, Haiduc2013}
that mitigate the necessity of a developer coming up with good search terms
by automatically generating query terms.
As an example, Kevic and Fritz propose a set of features to identify good search terms in 
a software development change task based on information available in the task~\cite{Kevic2014}.



Regardless of automatic or manual generation, if search terms 
differ significantly from the text of a document,
standard \acs{IR} algorithms will have 
little success in locating artifacts pertinent to a task~\cite{Huang2018}.
These so-called \textit{lexical mismatches}~\cite{Ye2016, silva2019} have led researchers to investigate 
 approaches able to establish semantic relationships between terms in software artifacts,
 which  Section~\ref{cp2:artifact-semantics} further details.







\subsection{Crowd Knowledge Approaches} 

A significant body or work has investigated 
methods---other than IR or ML---to
recommend artifacts that might assist a developer complete a software task
based on knowledge from other developers.






% (e.g.,
% Hipikat~\cite{Cubranic2005}, Libra~\cite{Ponzanelli2017},
% BIKER~\cite{Jiang2017}).  
% Hipikat relies on the concept of a
% group memory to recommend artifacts to a developer based on the current task.
% The group memory is formed by mining and relating artifacts
% associated with the software development~\cite{Cubranic2005}.
% Libra 
% keeps track of which artifacts are visited and recommends
% new artifacts to consider according to their prominence or complementarity to the
% visited ones~\cite{Ponzanelli2017}.  Finally, BIKER assists developers
% in selecting appropriate APIs for their tasks by using StackOverflow
% to capture how an API is often used~\cite{Jiang2017}.



% looking for artifacts that she judges pertinent to her task.
% To help developers address the initial problem of finding pertinent artifacts, 
% developed approaches use standard Information Retrieval (IR) techniques or more advanced ML techniques. 


